package com.chrylis.gbt.annotation

import java.lang.annotation.Documented
import java.lang.annotation.ElementType
import java.lang.annotation.Retention
import java.lang.annotation.RetentionPolicy
import java.lang.annotation.Target

import javax.persistence.CascadeType
import javax.persistence.FetchType
import javax.persistence.MapsId
import javax.persistence.OneToOne

import org.codehaus.groovy.transform.GroovyASTTransformationClass

import com.chrylis.gbt.transform.SubrecordTransformation

/**
 * Indicates that the annotated property is a <em>subrecord</em> of this entity.
 *
 * <p>Subrecord is a pattern that represents splitting parts of a relational record into separate
 * tables. This may be done for several reasons:
 * <ul>
 * <li>The subrecord columns are expensive to load and not usually needed.</li>
 * <li>The subrecord properties are only present on a handful of the main records, and indexing
 *     and cleanup are more efficient with a join table. <i>Example:</i> Password-reset tokens, which most
 *     user accounts will not have active at any given time, are usually queried for directly,
 *     and which should be able to be expired efficiently.</li>
 * <li>For management reasons, certain properties are considered sensitive and should not be
 *     processed by automatic tooling. <i>Example:</i> Passwords, where the (hashed!) password should not
 *     be either exposed by REST tooling or trivially updated with a write request.</li>
 * <li>For schema management, feature-specific columns should be added in a new table rather than
 *     included by altering the main table. <i>Example:</i> New two-factor authentication methods are
 *     supported, and it is preferable to create a new empty joined table (instant) instead of
 *     {@code ALTER TABLE ADD column} (which could take a long time and would probably be sparsely
 *     populated).</li>
 * </ul></p>
 *
 * <p>The subrecord has no independent identity; instead, it duplicates the main record's ID type
 * and uses {@link MapsId} to track it, meaning that at the database level it uses a single column
 * as both a primary key and a foreign key to the main record. The transformation also applies
 * two-way relationship management to the JPA mapping property; the subrecord is the owning side
 * of the relationship. It is semantically equivalent to
 * <pre>
 *     &#64;Id
 *     &lt;I&gt; id
 *
 *     &#64;OneToOne
 *     &#64;MapsId
 *     &#64;TwoWayRelationship
 *     MainRecord mainRecord
 * </pre></p>
 *
 * <p>Applying this annotation to a property on the main record applies {@link TwoWayRelationship},
 * and by default adds {@code @OneToOne(fetch = LAZY, cascade = ALL, mappedBy = "mainRecord")}.
 * In addition, if {@code createIfMissing} is true, a default instance is assigned to the field.
 * While similar to initializing with {@code Sub sub = new Sub()}, this transformation ensures that
 * the bidirectional relationship is set. The code for this is inserted in an object initializer,
 * so it runs before explicit constructor code and presents the relationship in a consistent state.</p>
 *
 * <p>Due to the limitations of the Groovy transformation sequence, Subrecord can only be applied
 * on a single level of relationships and cannot be nested. (Specifically, the ID field on the
 * main record is likely to be generated by {@link GbtId}, and this transformation pair both
 * generates the ID field on the subrecord and needs it to be available on the main record to
 * match its type.)</p>
 *
 * @author Christopher Smith
 *
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.CLASS)
@Documented
@GroovyASTTransformationClass(classes = SubrecordTransformation)
@interface Subrecord {

    /**
     * (Optional) The cascade setting to apply to the generated relationship.
     * @see OneToOne#cascade()
     */
    CascadeType[] cascade() default CascadeType.ALL;

    /**
     * (Optional) The default fetch setting to apply to the generated relationship.
     * @see OneToOne#fetch()
     */
    FetchType fetch() default FetchType.LAZY;

    /**
     * (Optional) Whether to create and bind an instance of the subrecord if the persistence
     *         provider does not initialize it (generally, if the subrecord's table is newly
     *         created and no subrecord exists for the main record).
     */
    boolean createIfMissing() default true;
}
